<html>
  <head>
    <script src="synaudio.min.js"></script>
  </head>
  <style></style>
  <body>
    <form>
      <fieldset name="base-upload" class="column">
        <legend>Base Audio</legend>
        <div style="width: 100%" class="row center">
          <input
            type="file"
            id="base-file-selector"
            accept=".mp3, .mp2, .mp1, .mpg, .ogg, .opus"
          />
        </div>
        <legend>Comparison Audio</legend>
        <div style="width: 100%" class="row center">
          <input
            type="file"
            id="comparison-file-selector"
            accept=".mp3, .mp2, .mp1, .mpg, .ogg, .opus"
          />
        </div>
      </fieldset>
      <fieldset id="fft-options">
        <legend>FFT Options</legend>
        <label for="fft-bins">Bin Size (height)</label>
        <select name="fft-bins" id="fft-bins">
          <option selected value="auto">auto</option>
        </select>
        <label for="fft-interval">Interval Size (width)</label>
        <select name="fft-interval" id="fft-interval">
          <option selected value="auto">auto</option>
        </select>
        <label for="fft-scale">Scale</label>
        <select name="fft-scale" id="fft-scale">
          <option selected value="log">logarithmic</option>
          <option value="lin">linear</option>
        </select>
      </fieldset>
    </form>
    <div id="base"></div>
    <div id="comparison"></div>
  </body>
  <script>
    "use strict";
    const audioCtx = new AudioContext();
    const fftCanvasInstances = new WeakMap();

    class FFTCanvas {
      static FFT_BIN_OPTIONS = [
        32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,
      ];

      static FFT_INTERVAL_OPTIONS = [256, 512, 1024, 2048, 4096, 8192, 16384];

      static async getInstance(data, canvasContainerId) {
        if (!data)
          return {
            buildFFT: () => {},
          };

        let instance = fftCanvasInstances.get(data);

        if (!instance) {
          const decoded = await audioCtx.decodeAudioData(data);
          instance = new FFTCanvas(decoded, canvasContainerId);
          fftCanvasInstances.set(data, instance);
        }
        return instance;
      }

      constructor(audioBuffer, canvasContainerId) {
        this.audioBuffer = audioBuffer;
        this._canvasContainerId = canvasContainerId;

        this._ffts = {};
      }

      get length() {
        return this.audioBuffer.length;
      }

      set displayLength(length) {
        this._displayLength = length || this.length;

        this.buildFFT();
      }

      get fftInterval() {
        const maxWidth = window.innerWidth;
        const fftInterval = document.getElementById("fft-interval").value;

        return fftInterval === "auto"
          ? FFTCanvas.FFT_INTERVAL_OPTIONS.reduceRight((acc, val) =>
              maxWidth > this._displayLength / val ? val : acc
            )
          : parseInt(fftInterval);
      }

      get fftBins() {
        const maxHeight = window.innerHeight * (1 / 2);
        const fftBins = document.getElementById("fft-bins").value;

        return fftBins === "auto"
          ? FFTCanvas.FFT_BIN_OPTIONS.reduceRight((acc, val) =>
              maxHeight < val ? val : acc
            )
          : parseInt(fftBins);
      }

      get fftScale() {
        return document.getElementById("fft-scale").value;
      }

      _newCanvasWorker() {
        const source = () => {
          let canvasXCursor = 0,
            canvasYCursor = 0;

          let canvas, canvasCtx, fftScale, sampleRate;

          self.onmessage = async ({ data: { name, payload } }) => {
            switch (name) {
              case "canvas":
                canvas = payload;
                canvasCtx = canvas.getContext("2d", { alpha: false });
                break;
              case "options":
                fftScale = payload.fftScale;
                sampleRate = payload.sampleRate;
                break;
              case "clear":
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                break;
              case "draw":
                for (const bins of payload) {
                  canvasYCursor = 0;

                  let canvasYPrevious;

                  const logGap =
                    bins.length /
                    ((Math.log10(bins.length - 1) * (bins.length - 1)) /
                      Math.log10(sampleRate / 2));

                  for (let binIdx = 0; binIdx < bins.length; binIdx++) {
                    canvasCtx.fillStyle = `rgb(0, ${bins[binIdx]}, ${bins[binIdx]})`;

                    canvasYPrevious = canvasYCursor;
                    canvasYCursor =
                      fftScale === "log"
                        ? Math.round(
                            ((Math.log10(binIdx) * (bins.length - 1)) /
                              Math.log10(sampleRate / 2)) *
                              logGap
                          )
                        : binIdx;

                    canvasCtx.fillRect(
                      canvasXCursor,
                      bins.length - canvasYCursor,
                      1,
                      canvasYCursor - canvasYPrevious
                    );
                  }

                  canvasXCursor++;
                }
                break;
            }
          };
        };

        if (this._canvasWorker) {
          this._clearCanvasWorker();
          this._terminateCanvasWorker();
        }

        this._canvasWorker = new Worker(
          URL.createObjectURL(
            new Blob([`"use strict";(${source.toString()})()`], {
              type: "text/javascript",
            })
          )
        );

        const canvas = document.createElement("CANVAS");
        canvas.id = this._canvasContainerId + "-canvas";
        canvas.width = this.audioBuffer.length / this.fftInterval;
        canvas.height = this.fftBins / 2;

        const canvasContainer = document.getElementById(
          this._canvasContainerId
        );
        canvasContainer.innerHTML = "";
        canvasContainer.appendChild(canvas);

        const offscreen = canvas.transferControlToOffscreen();

        this._canvasWorker.postMessage({ name: "canvas", payload: offscreen }, [
          offscreen,
        ]);
        this._canvasWorker.postMessage({
          name: "options",
          payload: {
            fftScale: this.fftScale,
            sampleRate: this.audioBuffer.sampleRate,
          },
        });
      }

      async _clearCanvasWorker() {
        let drawResolve, drawReject;
        const fftPromise = new Promise((resolve, reject) => {
          drawResolve = resolve;
          drawReject = reject;
        });

        this._canvasWorker.postMessage({ name: "clear" });
      }

      async _drawCanvasWorker(payload) {
        let drawResolve, drawReject;
        const fftPromise = new Promise((resolve, reject) => {
          drawResolve = resolve;
          drawReject = reject;
        });

        this._canvasWorker.postMessage({ name: "draw", payload });
      }

      _terminateCanvasWorker() {
        this._canvasWorker.terminate();
        this._canvasWorker = null;
      }

      async buildFFT() {
        this._newCanvasWorker();

        const fftBins = this.fftBins;
        const fftInterval = this.fftInterval;
        const fftKey = fftBins + "-" + fftInterval;

        if (this._ffts[fftKey]) {
          this._drawCanvasWorker(this._ffts[fftKey]);
        } else {
          this._ffts[fftKey] = [];

          const offlineAudioCtx = new OfflineAudioContext(this.audioBuffer);

          const source = offlineAudioCtx.createBufferSource(this.audioBuffer);
          source.buffer = this.audioBuffer;

          const analyzer = offlineAudioCtx.createAnalyser();
          analyzer.smoothingTimeConstant = 0;
          analyzer.fftSize = fftBins;

          const processor = offlineAudioCtx.createScriptProcessor(
            fftInterval,
            this.audioBuffer.numberOfChannels,
            this.audioBuffer.numberOfChannels
          );

          let fftChunk = [],
            processCount = 0,
            drawInterval = 32;

          processor.onaudioprocess = () => {
            const bins = new Uint8Array(analyzer.frequencyBinCount);
            analyzer.getByteFrequencyData(bins);
            this._ffts[fftKey].push(bins);
            fftChunk.push(bins);

            if (processCount++ % drawInterval === 0) {
              this._drawCanvasWorker(fftChunk);
              fftChunk = [];
            }
          };

          source.connect(analyzer);
          analyzer.connect(processor);
          processor.connect(offlineAudioCtx.destination);
          source.start(0);

          await offlineAudioCtx.startRendering();
          // draw any remaining data
          this._drawCanvasWorker(fftChunk);
        }
      }
    }

    const baseFileSelectorEl = document.getElementById("base-file-selector");
    const comparisonFileSelectorEl = document.getElementById(
      "comparison-file-selector"
    );

    let baseData, comparisonData;

    const rebuildFFTs = async () => {
      const baseInstance = await FFTCanvas.getInstance(baseData, "base");
      const comparisonInstance = await FFTCanvas.getInstance(
        comparisonData,
        "comparison"
      );

      const maxLength = Math.max(
        baseInstance.length,
        comparisonInstance.length
      );

      baseInstance.displayLength = maxLength;
      comparisonInstance.displayLength = maxLength;
    };

    baseFileSelectorEl.addEventListener("change", async (e) => {
      if (e.target.files.length) {
        baseData = await e.target.files[0].arrayBuffer();

        rebuildFFTs();
      }
    });

    comparisonFileSelectorEl.addEventListener("change", async (e) => {
      if (e.target.files.length) {
        comparisonData = await e.target.files[0].arrayBuffer();

        rebuildFFTs();
      }
    });

    const fftOptionsEl = document.getElementById("fft-options");
    fftOptionsEl.addEventListener("change", rebuildFFTs);

    // set FFT options
    const addOption = (el) => (value) =>
      (el.innerHTML += `<option value="${value}">${value}</option>`);

    const fftBinsEl = document.getElementById("fft-bins");
    const fftIntervalEl = document.getElementById("fft-interval");
    FFTCanvas.FFT_BIN_OPTIONS.forEach(addOption(fftBinsEl));
    FFTCanvas.FFT_INTERVAL_OPTIONS.forEach(addOption(fftIntervalEl));
  </script>
  <script>
    const findCovariance = async (base, comparison, method) => {};

    const synAudio = new SynAudio();

    /*const mpeg = await fetch("src/mpeg.cbr.mp3")
      .then((res) => res.arrayBuffer())
      .then((body) => new Uint8Array(body));

    const cutMpeg = await fetch("src/mpeg.cbr.1601425.mp3")
      .then((res) => res.arrayBuffer())
      .then((body) => new Uint8Array(body));

    const covariances = await synAudio.sync(mpeg, cutMpeg);*/
  </script>
</html>
